// Code generated by go generate via cmd/definitions; DO NOT EDIT.
package fs

import (
	"context"
	"io"
	"net/http"
	"time"

	. "github.com/beyondstorage/go-storage/v4/pairs"
	"github.com/beyondstorage/go-storage/v4/pkg/httpclient"
	"github.com/beyondstorage/go-storage/v4/services"
	. "github.com/beyondstorage/go-storage/v4/types"
)

var _ Storager
var _ services.ServiceError
var _ httpclient.Options
var _ time.Duration
var _ http.Request
var _ Error

// Type is the type for fs
const Type = "fs"

// ObjectSystemMetadata stores system metadata for object.
type ObjectSystemMetadata struct {
}

// GetObjectSystemMetadata will get ObjectSystemMetadata from Object.
//
// - This function should not be called by service implementer.
// - The returning ObjectServiceMetadata is read only and should not be modified.
func GetObjectSystemMetadata(o *Object) ObjectSystemMetadata {
	sm, ok := o.GetSystemMetadata()
	if ok {
		return sm.(ObjectSystemMetadata)
	}
	return ObjectSystemMetadata{}
}

// setObjectSystemMetadata will set ObjectSystemMetadata into Object.
//
// - This function should only be called once, please make sure all data has been written before set.
func setObjectSystemMetadata(o *Object, sm ObjectSystemMetadata) {
	o.SetSystemMetadata(sm)
}

// StorageSystemMetadata stores system metadata for storage meta.
type StorageSystemMetadata struct {
}

// GetStorageSystemMetadata will get SystemMetadata from StorageMeta.
//
// - The returning StorageSystemMetadata is read only and should not be modified.
func GetStorageSystemMetadata(s *StorageMeta) StorageSystemMetadata {
	sm, ok := s.GetSystemMetadata()
	if ok {
		return sm.(StorageSystemMetadata)
	}
	return StorageSystemMetadata{}
}

// setStorageSystemMetadata will set SystemMetadata into StorageMeta.
//
// - This function should only be called once, please make sure all data has been written before set.
func setStorageSystemMetadata(s *StorageMeta, sm StorageSystemMetadata) {
	s.SetSystemMetadata(sm)
}

// WithDefaultStoragePairs will apply default_storage_pairs value to Options.
//
// DefaultStoragePairs set default pairs for storager actions
func WithDefaultStoragePairs(v DefaultStoragePairs) Pair {
	return Pair{
		Key:   "default_storage_pairs",
		Value: v,
	}
}

// WithStorageFeatures will apply storage_features value to Options.
//
// StorageFeatures set storage features
func WithStorageFeatures(v StorageFeatures) Pair {
	return Pair{
		Key:   "storage_features",
		Value: v,
	}
}

var pairMap = map[string]string{
	"content_md5":           "string",
	"content_type":          "string",
	"context":               "context.Context",
	"continuation_token":    "string",
	"credential":            "string",
	"default_storage_pairs": "DefaultStoragePairs",
	"endpoint":              "string",
	"expire":                "time.Duration",
	"http_client_options":   "*httpclient.Options",
	"interceptor":           "Interceptor",
	"io_callback":           "func([]byte)",
	"list_mode":             "ListMode",
	"location":              "string",
	"multipart_id":          "string",
	"name":                  "string",
	"object_mode":           "ObjectMode",
	"offset":                "int64",
	"size":                  "int64",
	"storage_features":      "StorageFeatures",
	"work_dir":              "string",
}
var (
	_ Appender = &Storage{}
	_ Copier   = &Storage{}
	_ Direr    = &Storage{}
	_ Fetcher  = &Storage{}
	_ Linker   = &Storage{}
	_ Mover    = &Storage{}
	_ Storager = &Storage{}
)

type StorageFeatures struct {
}

// pairStorageNew is the parsed struct
type pairStorageNew struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasDefaultStoragePairs bool
	DefaultStoragePairs    DefaultStoragePairs
	HasStorageFeatures     bool
	StorageFeatures        StorageFeatures
	HasWorkDir             bool
	WorkDir                string
	// Enable features
	// Default pairs
}

// parsePairStorageNew will parse Pair slice into *pairStorageNew
func parsePairStorageNew(opts []Pair) (pairStorageNew, error) {
	result := pairStorageNew{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case "default_storage_pairs":
			if result.HasDefaultStoragePairs {
				continue
			}
			result.HasDefaultStoragePairs = true
			result.DefaultStoragePairs = v.Value.(DefaultStoragePairs)
		case "storage_features":
			if result.HasStorageFeatures {
				continue
			}
			result.HasStorageFeatures = true
			result.StorageFeatures = v.Value.(StorageFeatures)
		case "work_dir":
			if result.HasWorkDir {
				continue
			}
			result.HasWorkDir = true
			result.WorkDir = v.Value.(string)
			// Enable features
			// Default pairs
		}
	}

	// Enable features

	// Default pairs

	return result, nil
}

// DefaultStoragePairs is default pairs for specific action
type DefaultStoragePairs struct {
	CommitAppend []Pair
	Copy         []Pair
	Create       []Pair
	CreateAppend []Pair
	CreateDir    []Pair
	CreateLink   []Pair
	Delete       []Pair
	Fetch        []Pair
	List         []Pair
	Metadata     []Pair
	Move         []Pair
	Read         []Pair
	Stat         []Pair
	Write        []Pair
	WriteAppend  []Pair
}

// pairStorageCommitAppend is the parsed struct
type pairStorageCommitAppend struct {
	pairs []Pair
}

// parsePairStorageCommitAppend will parse Pair slice into *pairStorageCommitAppend
func (s *Storage) parsePairStorageCommitAppend(opts []Pair) (pairStorageCommitAppend, error) {
	result := pairStorageCommitAppend{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageCommitAppend{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageCopy is the parsed struct
type pairStorageCopy struct {
	pairs []Pair
}

// parsePairStorageCopy will parse Pair slice into *pairStorageCopy
func (s *Storage) parsePairStorageCopy(opts []Pair) (pairStorageCopy, error) {
	result := pairStorageCopy{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageCopy{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageCreate is the parsed struct
type pairStorageCreate struct {
	pairs         []Pair
	HasObjectMode bool
	ObjectMode    ObjectMode
}

// parsePairStorageCreate will parse Pair slice into *pairStorageCreate
func (s *Storage) parsePairStorageCreate(opts []Pair) (pairStorageCreate, error) {
	result := pairStorageCreate{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		case "object_mode":
			if result.HasObjectMode {
				continue
			}
			result.HasObjectMode = true
			result.ObjectMode = v.Value.(ObjectMode)
			continue
		default:
			return pairStorageCreate{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageCreateAppend is the parsed struct
type pairStorageCreateAppend struct {
	pairs []Pair
}

// parsePairStorageCreateAppend will parse Pair slice into *pairStorageCreateAppend
func (s *Storage) parsePairStorageCreateAppend(opts []Pair) (pairStorageCreateAppend, error) {
	result := pairStorageCreateAppend{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageCreateAppend{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageCreateDir is the parsed struct
type pairStorageCreateDir struct {
	pairs []Pair
}

// parsePairStorageCreateDir will parse Pair slice into *pairStorageCreateDir
func (s *Storage) parsePairStorageCreateDir(opts []Pair) (pairStorageCreateDir, error) {
	result := pairStorageCreateDir{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageCreateDir{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageCreateLink is the parsed struct
type pairStorageCreateLink struct {
	pairs []Pair
}

// parsePairStorageCreateLink will parse Pair slice into *pairStorageCreateLink
func (s *Storage) parsePairStorageCreateLink(opts []Pair) (pairStorageCreateLink, error) {
	result := pairStorageCreateLink{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageCreateLink{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageDelete is the parsed struct
type pairStorageDelete struct {
	pairs         []Pair
	HasObjectMode bool
	ObjectMode    ObjectMode
}

// parsePairStorageDelete will parse Pair slice into *pairStorageDelete
func (s *Storage) parsePairStorageDelete(opts []Pair) (pairStorageDelete, error) {
	result := pairStorageDelete{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		case "object_mode":
			if result.HasObjectMode {
				continue
			}
			result.HasObjectMode = true
			result.ObjectMode = v.Value.(ObjectMode)
			continue
		default:
			return pairStorageDelete{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageFetch is the parsed struct
type pairStorageFetch struct {
	pairs []Pair
}

// parsePairStorageFetch will parse Pair slice into *pairStorageFetch
func (s *Storage) parsePairStorageFetch(opts []Pair) (pairStorageFetch, error) {
	result := pairStorageFetch{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageFetch{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageList is the parsed struct
type pairStorageList struct {
	pairs                []Pair
	HasContinuationToken bool
	ContinuationToken    string
	HasListMode          bool
	ListMode             ListMode
}

// parsePairStorageList will parse Pair slice into *pairStorageList
func (s *Storage) parsePairStorageList(opts []Pair) (pairStorageList, error) {
	result := pairStorageList{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		case "continuation_token":
			if result.HasContinuationToken {
				continue
			}
			result.HasContinuationToken = true
			result.ContinuationToken = v.Value.(string)
			continue
		case "list_mode":
			if result.HasListMode {
				continue
			}
			result.HasListMode = true
			result.ListMode = v.Value.(ListMode)
			continue
		default:
			return pairStorageList{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageMetadata is the parsed struct
type pairStorageMetadata struct {
	pairs []Pair
}

// parsePairStorageMetadata will parse Pair slice into *pairStorageMetadata
func (s *Storage) parsePairStorageMetadata(opts []Pair) (pairStorageMetadata, error) {
	result := pairStorageMetadata{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageMetadata{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageMove is the parsed struct
type pairStorageMove struct {
	pairs []Pair
}

// parsePairStorageMove will parse Pair slice into *pairStorageMove
func (s *Storage) parsePairStorageMove(opts []Pair) (pairStorageMove, error) {
	result := pairStorageMove{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageMove{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageRead is the parsed struct
type pairStorageRead struct {
	pairs         []Pair
	HasIoCallback bool
	IoCallback    func([]byte)
	HasOffset     bool
	Offset        int64
	HasSize       bool
	Size          int64
}

// parsePairStorageRead will parse Pair slice into *pairStorageRead
func (s *Storage) parsePairStorageRead(opts []Pair) (pairStorageRead, error) {
	result := pairStorageRead{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		case "io_callback":
			if result.HasIoCallback {
				continue
			}
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
			continue
		case "offset":
			if result.HasOffset {
				continue
			}
			result.HasOffset = true
			result.Offset = v.Value.(int64)
			continue
		case "size":
			if result.HasSize {
				continue
			}
			result.HasSize = true
			result.Size = v.Value.(int64)
			continue
		default:
			return pairStorageRead{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageStat is the parsed struct
type pairStorageStat struct {
	pairs         []Pair
	HasObjectMode bool
	ObjectMode    ObjectMode
}

// parsePairStorageStat will parse Pair slice into *pairStorageStat
func (s *Storage) parsePairStorageStat(opts []Pair) (pairStorageStat, error) {
	result := pairStorageStat{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		case "object_mode":
			if result.HasObjectMode {
				continue
			}
			result.HasObjectMode = true
			result.ObjectMode = v.Value.(ObjectMode)
			continue
		default:
			return pairStorageStat{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageWrite is the parsed struct
type pairStorageWrite struct {
	pairs          []Pair
	HasContentMd5  bool
	ContentMd5     string
	HasContentType bool
	ContentType    string
	HasIoCallback  bool
	IoCallback     func([]byte)
	HasOffset      bool
	Offset         int64
}

// parsePairStorageWrite will parse Pair slice into *pairStorageWrite
func (s *Storage) parsePairStorageWrite(opts []Pair) (pairStorageWrite, error) {
	result := pairStorageWrite{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		case "content_md5":
			if result.HasContentMd5 {
				continue
			}
			result.HasContentMd5 = true
			result.ContentMd5 = v.Value.(string)
			continue
		case "content_type":
			if result.HasContentType {
				continue
			}
			result.HasContentType = true
			result.ContentType = v.Value.(string)
			continue
		case "io_callback":
			if result.HasIoCallback {
				continue
			}
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
			continue
		case "offset":
			if result.HasOffset {
				continue
			}
			result.HasOffset = true
			result.Offset = v.Value.(int64)
			continue
		default:
			return pairStorageWrite{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageWriteAppend is the parsed struct
type pairStorageWriteAppend struct {
	pairs []Pair
}

// parsePairStorageWriteAppend will parse Pair slice into *pairStorageWriteAppend
func (s *Storage) parsePairStorageWriteAppend(opts []Pair) (pairStorageWriteAppend, error) {
	result := pairStorageWriteAppend{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageWriteAppend{}, services.PairUnsupportedError{Pair: v}
		}
	}

	// Check required pairs.

	return result, nil
}

// CommitAppend will commit and finish an append process.
//
// This function will create a context by default.
func (s *Storage) CommitAppend(o *Object, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.CommitAppendWithContext(ctx, o, pairs...)
}

// CommitAppendWithContext will commit and finish an append process.
func (s *Storage) CommitAppendWithContext(ctx context.Context, o *Object, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("commit_append", err)
	}()
	if !o.Mode.IsAppend() {
		err = services.ObjectModeInvalidError{Expected: ModeAppend, Actual: o.Mode}
		return
	}

	pairs = append(pairs, s.defaultPairs.CommitAppend...)
	var opt pairStorageCommitAppend

	opt, err = s.parsePairStorageCommitAppend(pairs)
	if err != nil {
		return
	}

	return s.commitAppend(ctx, o, opt)
}

// Copy will copy an Object or multiple object in the service.
//
// ## Behavior
//
// - Copy only copy one and only one object.
//   - Service DON'T NEED to support copy a non-empty directory or copy files recursively.
//   - User NEED to implement copy a non-empty directory and copy recursively by themself.
//   - Copy a file to a directory SHOULD return `ErrObjectModeInvalid`.
// - Copy SHOULD NOT return an error as dst object exists.
//   - Service that has native support for `overwrite` doesn't NEED to check the dst object exists or not.
//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the dst object if exists.
// - A successful copy opration should be complete, which means the dst object's content and metadata should be the same as src object.
//
// This function will create a context by default.
func (s *Storage) Copy(src string, dst string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.CopyWithContext(ctx, src, dst, pairs...)
}

// CopyWithContext will copy an Object or multiple object in the service.
//
// ## Behavior
//
// - Copy only copy one and only one object.
//   - Service DON'T NEED to support copy a non-empty directory or copy files recursively.
//   - User NEED to implement copy a non-empty directory and copy recursively by themself.
//   - Copy a file to a directory SHOULD return `ErrObjectModeInvalid`.
// - Copy SHOULD NOT return an error as dst object exists.
//   - Service that has native support for `overwrite` doesn't NEED to check the dst object exists or not.
//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the dst object if exists.
// - A successful copy opration should be complete, which means the dst object's content and metadata should be the same as src object.
func (s *Storage) CopyWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("copy", err, src, dst)
	}()

	pairs = append(pairs, s.defaultPairs.Copy...)
	var opt pairStorageCopy

	opt, err = s.parsePairStorageCopy(pairs)
	if err != nil {
		return
	}

	return s.copy(ctx, src, dst, opt)
}

// Create will create a new object without any api call.
//
// ## Behavior
//
// - Create SHOULD NOT send any API call.
// - Create SHOULD accept ObjectMode pair as object mode.
//
// This function will create a context by default.
func (s *Storage) Create(path string, pairs ...Pair) (o *Object) {
	pairs = append(pairs, s.defaultPairs.Create...)
	var opt pairStorageCreate

	// Ignore error while handling local funtions.
	opt, _ = s.parsePairStorageCreate(pairs)

	return s.create(path, opt)
}

// CreateAppend will create an append object.
//
// ## Behavior
//
// - CreateAppend SHOULD create an appendable object with position 0 and size 0.
// - CreateAppend SHOULD NOT return an error as the object exist.
//   - Service SHOULD check and delete the object if exists.
//
// This function will create a context by default.
func (s *Storage) CreateAppend(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.CreateAppendWithContext(ctx, path, pairs...)
}

// CreateAppendWithContext will create an append object.
//
// ## Behavior
//
// - CreateAppend SHOULD create an appendable object with position 0 and size 0.
// - CreateAppend SHOULD NOT return an error as the object exist.
//   - Service SHOULD check and delete the object if exists.
func (s *Storage) CreateAppendWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err = s.formatError("create_append", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreateAppend...)
	var opt pairStorageCreateAppend

	opt, err = s.parsePairStorageCreateAppend(pairs)
	if err != nil {
		return
	}

	return s.createAppend(ctx, path, opt)
}

// CreateDir will create a new dir object.
//
// This function will create a context by default.
func (s *Storage) CreateDir(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.CreateDirWithContext(ctx, path, pairs...)
}

// CreateDirWithContext will create a new dir object.
func (s *Storage) CreateDirWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err = s.formatError("create_dir", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreateDir...)
	var opt pairStorageCreateDir

	opt, err = s.parsePairStorageCreateDir(pairs)
	if err != nil {
		return
	}

	return s.createDir(ctx, path, opt)
}

// CreateLink Will create a link object.
//
// # Behavior
//
// - `path` and `target` COULD be relative or absolute path.
// - If `target` not exists, CreateLink will still create a link object to path.
// - If `path` exists:
//   - If `path` is a symlink object, CreateLink will remove the symlink object and create a new link object to path.
//   - If `path` is not a symlink object, CreateLink will return an ErrObjectModeInvalid error when the service does not support overwrite.
// - A link object COULD be returned in `Stat` or `List`.
// - CreateLink COULD implement virtual_link feature when service without native support.
//   - Users SHOULD enable this feature by themselves.
//
// This function will create a context by default.
func (s *Storage) CreateLink(path string, target string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.CreateLinkWithContext(ctx, path, target, pairs...)
}

// CreateLinkWithContext Will create a link object.
//
// # Behavior
//
// - `path` and `target` COULD be relative or absolute path.
// - If `target` not exists, CreateLink will still create a link object to path.
// - If `path` exists:
//   - If `path` is a symlink object, CreateLink will remove the symlink object and create a new link object to path.
//   - If `path` is not a symlink object, CreateLink will return an ErrObjectModeInvalid error when the service does not support overwrite.
// - A link object COULD be returned in `Stat` or `List`.
// - CreateLink COULD implement virtual_link feature when service without native support.
//   - Users SHOULD enable this feature by themselves.
func (s *Storage) CreateLinkWithContext(ctx context.Context, path string, target string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err = s.formatError("create_link", err, path, target)
	}()

	pairs = append(pairs, s.defaultPairs.CreateLink...)
	var opt pairStorageCreateLink

	opt, err = s.parsePairStorageCreateLink(pairs)
	if err != nil {
		return
	}

	return s.createLink(ctx, path, target, opt)
}

// Delete will delete an object from service.
//
// ## Behavior
//
// - Delete only delete one and only one object.
//   - Service DON'T NEED to support remove all.
//   - User NEED to implement remove_all by themself.
// - Delete is idempotent.
//   - Successful delete always return nil error.
//   - Delete SHOULD never return `ObjectNotExist`
//   - Delete DON'T NEED to check the object exist or not.
//
// This function will create a context by default.
func (s *Storage) Delete(path string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.DeleteWithContext(ctx, path, pairs...)
}

// DeleteWithContext will delete an object from service.
//
// ## Behavior
//
// - Delete only delete one and only one object.
//   - Service DON'T NEED to support remove all.
//   - User NEED to implement remove_all by themself.
// - Delete is idempotent.
//   - Successful delete always return nil error.
//   - Delete SHOULD never return `ObjectNotExist`
//   - Delete DON'T NEED to check the object exist or not.
func (s *Storage) DeleteWithContext(ctx context.Context, path string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("delete", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Delete...)
	var opt pairStorageDelete

	opt, err = s.parsePairStorageDelete(pairs)
	if err != nil {
		return
	}

	return s.delete(ctx, path, opt)
}

// Fetch will fetch from a given url to path.
//
// ## Behavior
//
// - Fetch SHOULD NOT return an error as the object exists.
// - A successful fetch operation should be complete, which means the object's content and metadata should be the same as requiring from the url.
//
// This function will create a context by default.
func (s *Storage) Fetch(path string, url string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.FetchWithContext(ctx, path, url, pairs...)
}

// FetchWithContext will fetch from a given url to path.
//
// ## Behavior
//
// - Fetch SHOULD NOT return an error as the object exists.
// - A successful fetch operation should be complete, which means the object's content and metadata should be the same as requiring from the url.
func (s *Storage) FetchWithContext(ctx context.Context, path string, url string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("fetch", err, path, url)
	}()

	pairs = append(pairs, s.defaultPairs.Fetch...)
	var opt pairStorageFetch

	opt, err = s.parsePairStorageFetch(pairs)
	if err != nil {
		return
	}

	return s.fetch(ctx, path, url, opt)
}

// List will return list a specific path.
//
// ## Behavior
//
// - Service SHOULD support default `ListMode`.
// - Service SHOULD implement `ListModeDir` without the check for `VirtualDir`.
// - Service DON'T NEED to `Stat` while in `List`.
//
// This function will create a context by default.
func (s *Storage) List(path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	ctx := context.Background()
	return s.ListWithContext(ctx, path, pairs...)
}

// ListWithContext will return list a specific path.
//
// ## Behavior
//
// - Service SHOULD support default `ListMode`.
// - Service SHOULD implement `ListModeDir` without the check for `VirtualDir`.
// - Service DON'T NEED to `Stat` while in `List`.
func (s *Storage) ListWithContext(ctx context.Context, path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	defer func() {
		err = s.formatError("list", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.List...)
	var opt pairStorageList

	opt, err = s.parsePairStorageList(pairs)
	if err != nil {
		return
	}

	return s.list(ctx, path, opt)
}

// Metadata will return current storager metadata.
//
// This function will create a context by default.
func (s *Storage) Metadata(pairs ...Pair) (meta *StorageMeta) {
	pairs = append(pairs, s.defaultPairs.Metadata...)
	var opt pairStorageMetadata

	// Ignore error while handling local funtions.
	opt, _ = s.parsePairStorageMetadata(pairs)

	return s.metadata(opt)
}

// Move will move an object in the service.
//
// ## Behavior
//
// - Move only move one and only one object.
//   - Service DON'T NEED to support move a non-empty directory.
//   - User NEED to implement move a non-empty directory by themself.
//   - Move a file to a directory SHOULD return `ErrObjectModeInvalid`.
// - Move SHOULD NOT return an error as dst object exists.
//   - Service that has native support for `overwrite` doesn't NEED to check the dst object exists or not.
//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the dst object if exists.
// - A successful move operation SHOULD be complete, which means the dst object's content and metadata should be the same as src object.
//
// This function will create a context by default.
func (s *Storage) Move(src string, dst string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.MoveWithContext(ctx, src, dst, pairs...)
}

// MoveWithContext will move an object in the service.
//
// ## Behavior
//
// - Move only move one and only one object.
//   - Service DON'T NEED to support move a non-empty directory.
//   - User NEED to implement move a non-empty directory by themself.
//   - Move a file to a directory SHOULD return `ErrObjectModeInvalid`.
// - Move SHOULD NOT return an error as dst object exists.
//   - Service that has native support for `overwrite` doesn't NEED to check the dst object exists or not.
//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the dst object if exists.
// - A successful move operation SHOULD be complete, which means the dst object's content and metadata should be the same as src object.
func (s *Storage) MoveWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("move", err, src, dst)
	}()

	pairs = append(pairs, s.defaultPairs.Move...)
	var opt pairStorageMove

	opt, err = s.parsePairStorageMove(pairs)
	if err != nil {
		return
	}

	return s.move(ctx, src, dst, opt)
}

// Read will read the file's data.
//
// This function will create a context by default.
func (s *Storage) Read(path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.ReadWithContext(ctx, path, w, pairs...)
}

// ReadWithContext will read the file's data.
func (s *Storage) ReadWithContext(ctx context.Context, path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	defer func() {
		err = s.formatError("read", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Read...)
	var opt pairStorageRead

	opt, err = s.parsePairStorageRead(pairs)
	if err != nil {
		return
	}

	return s.read(ctx, path, w, opt)
}

// Stat will stat a path to get info of an object.
//
// ## Behavior
//
// - Stat SHOULD accept ObjectMode pair as hints.
//   - Service COULD have different implementations for different object mode.
//   - Service SHOULD check if returning ObjectMode is match
//
// This function will create a context by default.
func (s *Storage) Stat(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.StatWithContext(ctx, path, pairs...)
}

// StatWithContext will stat a path to get info of an object.
//
// ## Behavior
//
// - Stat SHOULD accept ObjectMode pair as hints.
//   - Service COULD have different implementations for different object mode.
//   - Service SHOULD check if returning ObjectMode is match
func (s *Storage) StatWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err = s.formatError("stat", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Stat...)
	var opt pairStorageStat

	opt, err = s.parsePairStorageStat(pairs)
	if err != nil {
		return
	}

	return s.stat(ctx, path, opt)
}

// Write will write data into a file.
//
// ## Behavior
//
// - Write SHOULD NOT return an error as the object exist.
//   - Service that has native support for `overwrite` doesn't NEED to check the object exists or not.
//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the object if exists.
// - A successful write operation SHOULD be complete, which means the object's content and metadata should be the same as specified in write request.
//
// This function will create a context by default.
func (s *Storage) Write(path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteWithContext(ctx, path, r, size, pairs...)
}

// WriteWithContext will write data into a file.
//
// ## Behavior
//
// - Write SHOULD NOT return an error as the object exist.
//   - Service that has native support for `overwrite` doesn't NEED to check the object exists or not.
//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the object if exists.
// - A successful write operation SHOULD be complete, which means the object's content and metadata should be the same as specified in write request.
func (s *Storage) WriteWithContext(ctx context.Context, path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	defer func() {
		err = s.formatError("write", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Write...)
	var opt pairStorageWrite

	opt, err = s.parsePairStorageWrite(pairs)
	if err != nil {
		return
	}

	return s.write(ctx, path, r, size, opt)
}

// WriteAppend will append content to an append object.
//
// This function will create a context by default.
func (s *Storage) WriteAppend(o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteAppendWithContext(ctx, o, r, size, pairs...)
}

// WriteAppendWithContext will append content to an append object.
func (s *Storage) WriteAppendWithContext(ctx context.Context, o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	defer func() {
		err = s.formatError("write_append", err)
	}()
	if !o.Mode.IsAppend() {
		err = services.ObjectModeInvalidError{Expected: ModeAppend, Actual: o.Mode}
		return
	}

	pairs = append(pairs, s.defaultPairs.WriteAppend...)
	var opt pairStorageWriteAppend

	opt, err = s.parsePairStorageWriteAppend(pairs)
	if err != nil {
		return
	}

	return s.writeAppend(ctx, o, r, size, opt)
}

func init() {
	services.RegisterStorager(Type, NewStorager)
	services.RegisterSchema(Type, pairMap)
}
