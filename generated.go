// Code generated by go generate via cmd/definitions; DO NOT EDIT.
package fs

import (
	"context"
	"io"

	"github.com/beyondstorage/go-storage/v4/pkg/credential"
	"github.com/beyondstorage/go-storage/v4/pkg/endpoint"
	"github.com/beyondstorage/go-storage/v4/pkg/httpclient"
	"github.com/beyondstorage/go-storage/v4/services"
	. "github.com/beyondstorage/go-storage/v4/types"
)

var _ credential.Provider
var _ endpoint.Value
var _ Storager
var _ services.ServiceError
var _ httpclient.Options

// Type is the type for fs
const Type = "fs"

// Service available pairs.
const (
	// DefaultStoragePairs set default pairs for storager actions
	pairDefaultStoragePairs = "fs_default_storage_pairs"
	// StorageFeatures set storage features
	pairStorageFeatures = "fs_storage_features"
)

// ObjectMetadata stores service metadata for object.
type ObjectMetadata struct {
}

// GetObjectMetadata will get ObjectMetadata from Object.
//
// - This function should not be called by service implementer.
// - The returning ObjectMetadata is read only and should not be modified.
func GetObjectMetadata(o *Object) ObjectMetadata {
	om, ok := o.GetServiceMetadata()
	if ok {
		return om.(ObjectMetadata)
	}
	return ObjectMetadata{}
}

// setObjectMetadata will set ObjectMetadata into Object.
//
// - This function should only be called once, please make sure all data has been written before set.
func setObjectMetadata(o *Object, om ObjectMetadata) {
	o.SetServiceMetadata(om)
}

// WithDefaultStoragePairs will apply default_storage_pairs value to Options.
//
// DefaultStoragePairs set default pairs for storager actions
func WithDefaultStoragePairs(v DefaultStoragePairs) Pair {
	return Pair{
		Key:   pairDefaultStoragePairs,
		Value: v,
	}
}

// WithStorageFeatures will apply storage_features value to Options.
//
// StorageFeatures set storage features
func WithStorageFeatures(v StorageFeatures) Pair {
	return Pair{
		Key:   pairStorageFeatures,
		Value: v,
	}
}

var (
	_ Appender = &Storage{}
	_ Copier   = &Storage{}
	_ Direr    = &Storage{}
	_ Fetcher  = &Storage{}
	_ Mover    = &Storage{}
	_ Storager = &Storage{}
)

type StorageFeatures struct {
	LooseOperationAll          bool
	LooseOperationCommitAppend bool
	LooseOperationCopy         bool
	LooseOperationCreate       bool
	LooseOperationCreateAppend bool
	LooseOperationCreateDir    bool
	LooseOperationDelete       bool
	LooseOperationFetch        bool
	LooseOperationList         bool
	LooseOperationMetadata     bool
	LooseOperationMove         bool
	LooseOperationRead         bool
	LooseOperationStat         bool
	LooseOperationWrite        bool
	LooseOperationWriteAppend  bool

	VirtualOperationAll bool

	VirtualPairAll              bool
	VirtualPairWriteAll         bool
	VirtualPairWriteContentMd5  bool
	VirtualPairWriteContentType bool
}

// pairStorageNew is the parsed struct
type pairStorageNew struct {
	pairs []Pair

	// Required pairs
	// Optional pairs
	HasDefaultStoragePairs bool
	DefaultStoragePairs    DefaultStoragePairs
	HasStorageFeatures     bool
	StorageFeatures        StorageFeatures
	HasWorkDir             bool
	WorkDir                string
}

// parsePairStorageNew will parse Pair slice into *pairStorageNew
func parsePairStorageNew(opts []Pair) (pairStorageNew, error) {
	result := pairStorageNew{
		pairs: opts,
	}

	for _, v := range opts {
		switch v.Key {
		// Required pairs
		// Optional pairs
		case pairDefaultStoragePairs:
			if result.HasDefaultStoragePairs {
				continue
			}
			result.HasDefaultStoragePairs = true
			result.DefaultStoragePairs = v.Value.(DefaultStoragePairs)
		case pairStorageFeatures:
			if result.HasStorageFeatures {
				continue
			}
			result.HasStorageFeatures = true
			result.StorageFeatures = v.Value.(StorageFeatures)
		case "work_dir":
			if result.HasWorkDir {
				continue
			}
			result.HasWorkDir = true
			result.WorkDir = v.Value.(string)
		}
	}

	return result, nil
}

// DefaultStoragePairs is default pairs for specific action
type DefaultStoragePairs struct {
	CommitAppend []Pair
	Copy         []Pair
	Create       []Pair
	CreateAppend []Pair
	CreateDir    []Pair
	Delete       []Pair
	Fetch        []Pair
	List         []Pair
	Metadata     []Pair
	Move         []Pair
	Read         []Pair
	Stat         []Pair
	Write        []Pair
	WriteAppend  []Pair
}

// pairStorageCommitAppend is the parsed struct
type pairStorageCommitAppend struct {
	pairs []Pair
}

// parsePairStorageCommitAppend will parse Pair slice into *pairStorageCommitAppend
func (s *Storage) parsePairStorageCommitAppend(opts []Pair) (pairStorageCommitAppend, error) {
	result := pairStorageCommitAppend{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationCommitAppend {
			continue
		}
		return pairStorageCommitAppend{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageCopy is the parsed struct
type pairStorageCopy struct {
	pairs []Pair
}

// parsePairStorageCopy will parse Pair slice into *pairStorageCopy
func (s *Storage) parsePairStorageCopy(opts []Pair) (pairStorageCopy, error) {
	result := pairStorageCopy{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationCopy {
			continue
		}
		return pairStorageCopy{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageCreate is the parsed struct
type pairStorageCreate struct {
	pairs          []Pair
	HasMultipartID bool
	MultipartID    string
}

// parsePairStorageCreate will parse Pair slice into *pairStorageCreate
func (s *Storage) parsePairStorageCreate(opts []Pair) (pairStorageCreate, error) {
	result := pairStorageCreate{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		case "multipart_id":
			if result.HasMultipartID {
				continue
			}
			result.HasMultipartID = true
			result.MultipartID = v.Value.(string)
			continue
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationCreate {
			continue
		}
		return pairStorageCreate{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageCreateAppend is the parsed struct
type pairStorageCreateAppend struct {
	pairs []Pair
}

// parsePairStorageCreateAppend will parse Pair slice into *pairStorageCreateAppend
func (s *Storage) parsePairStorageCreateAppend(opts []Pair) (pairStorageCreateAppend, error) {
	result := pairStorageCreateAppend{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationCreateAppend {
			continue
		}
		return pairStorageCreateAppend{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageCreateDir is the parsed struct
type pairStorageCreateDir struct {
	pairs []Pair
}

// parsePairStorageCreateDir will parse Pair slice into *pairStorageCreateDir
func (s *Storage) parsePairStorageCreateDir(opts []Pair) (pairStorageCreateDir, error) {
	result := pairStorageCreateDir{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationCreateDir {
			continue
		}
		return pairStorageCreateDir{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageDelete is the parsed struct
type pairStorageDelete struct {
	pairs []Pair
}

// parsePairStorageDelete will parse Pair slice into *pairStorageDelete
func (s *Storage) parsePairStorageDelete(opts []Pair) (pairStorageDelete, error) {
	result := pairStorageDelete{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationDelete {
			continue
		}
		return pairStorageDelete{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageFetch is the parsed struct
type pairStorageFetch struct {
	pairs []Pair
}

// parsePairStorageFetch will parse Pair slice into *pairStorageFetch
func (s *Storage) parsePairStorageFetch(opts []Pair) (pairStorageFetch, error) {
	result := pairStorageFetch{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationFetch {
			continue
		}
		return pairStorageFetch{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageList is the parsed struct
type pairStorageList struct {
	pairs                []Pair
	HasContinuationToken bool
	ContinuationToken    string
	HasListMode          bool
	ListMode             ListMode
}

// parsePairStorageList will parse Pair slice into *pairStorageList
func (s *Storage) parsePairStorageList(opts []Pair) (pairStorageList, error) {
	result := pairStorageList{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		case "continuation_token":
			if result.HasContinuationToken {
				continue
			}
			result.HasContinuationToken = true
			result.ContinuationToken = v.Value.(string)
			continue
		case "list_mode":
			if result.HasListMode {
				continue
			}
			result.HasListMode = true
			result.ListMode = v.Value.(ListMode)
			continue
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationList {
			continue
		}
		return pairStorageList{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageMetadata is the parsed struct
type pairStorageMetadata struct {
	pairs []Pair
}

// parsePairStorageMetadata will parse Pair slice into *pairStorageMetadata
func (s *Storage) parsePairStorageMetadata(opts []Pair) (pairStorageMetadata, error) {
	result := pairStorageMetadata{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationMetadata {
			continue
		}
		return pairStorageMetadata{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageMove is the parsed struct
type pairStorageMove struct {
	pairs []Pair
}

// parsePairStorageMove will parse Pair slice into *pairStorageMove
func (s *Storage) parsePairStorageMove(opts []Pair) (pairStorageMove, error) {
	result := pairStorageMove{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationMove {
			continue
		}
		return pairStorageMove{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageRead is the parsed struct
type pairStorageRead struct {
	pairs         []Pair
	HasIoCallback bool
	IoCallback    func([]byte)
	HasOffset     bool
	Offset        int64
	HasSize       bool
	Size          int64
}

// parsePairStorageRead will parse Pair slice into *pairStorageRead
func (s *Storage) parsePairStorageRead(opts []Pair) (pairStorageRead, error) {
	result := pairStorageRead{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		case "io_callback":
			if result.HasIoCallback {
				continue
			}
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
			continue
		case "offset":
			if result.HasOffset {
				continue
			}
			result.HasOffset = true
			result.Offset = v.Value.(int64)
			continue
		case "size":
			if result.HasSize {
				continue
			}
			result.HasSize = true
			result.Size = v.Value.(int64)
			continue
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationRead {
			continue
		}
		return pairStorageRead{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageStat is the parsed struct
type pairStorageStat struct {
	pairs []Pair
}

// parsePairStorageStat will parse Pair slice into *pairStorageStat
func (s *Storage) parsePairStorageStat(opts []Pair) (pairStorageStat, error) {
	result := pairStorageStat{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationStat {
			continue
		}
		return pairStorageStat{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageWrite is the parsed struct
type pairStorageWrite struct {
	pairs          []Pair
	HasIoCallback  bool
	IoCallback     func([]byte)
	HasOffset      bool
	Offset         int64
	HasContentMd5  bool
	ContentMd5     string
	HasContentType bool
	ContentType    string
}

// parsePairStorageWrite will parse Pair slice into *pairStorageWrite
func (s *Storage) parsePairStorageWrite(opts []Pair) (pairStorageWrite, error) {
	result := pairStorageWrite{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		case "io_callback":
			if result.HasIoCallback {
				continue
			}
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
			continue
		case "offset":
			if result.HasOffset {
				continue
			}
			result.HasOffset = true
			result.Offset = v.Value.(int64)
			continue
		case "content_md5":
			if result.HasContentMd5 {
				continue
			}
			// If user enables the virtual pair feature, we can pass the virtual pair into it.
			if s.features.VirtualPairAll || s.features.VirtualPairWriteAll || s.features.VirtualPairWriteContentMd5 {
				result.HasContentMd5 = true
				result.ContentMd5 = v.Value.(string)
				continue
			}
			isUnsupportedPair = true
		case "content_type":
			if result.HasContentType {
				continue
			}
			// If user enables the virtual pair feature, we can pass the virtual pair into it.
			if s.features.VirtualPairAll || s.features.VirtualPairWriteAll || s.features.VirtualPairWriteContentType {
				result.HasContentType = true
				result.ContentType = v.Value.(string)
				continue
			}
			isUnsupportedPair = true
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationWrite {
			continue
		}
		return pairStorageWrite{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// pairStorageWriteAppend is the parsed struct
type pairStorageWriteAppend struct {
	pairs []Pair
}

// parsePairStorageWriteAppend will parse Pair slice into *pairStorageWriteAppend
func (s *Storage) parsePairStorageWriteAppend(opts []Pair) (pairStorageWriteAppend, error) {
	result := pairStorageWriteAppend{
		pairs: opts,
	}

	for _, v := range opts {
		// isUnsupportedPair records whether current pair is unsupported.
		isUnsupportedPair := false

		switch v.Key {
		default:
			isUnsupportedPair = true
		}

		if !isUnsupportedPair {
			continue
		}

		// If user enables the loose operation feature, we will ignore PairUnsupportedError.
		if s.features.LooseOperationAll || s.features.LooseOperationWriteAppend {
			continue
		}
		return pairStorageWriteAppend{}, services.PairUnsupportedError{Pair: v}
	}

	// Check required pairs.

	return result, nil
}

// CommitAppend will commit and finish an append process.
//
// This function will create a context by default.
func (s *Storage) CommitAppend(o *Object, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.CommitAppendWithContext(ctx, o, pairs...)
}

// CommitAppendWithContext will commit and finish an append process.
func (s *Storage) CommitAppendWithContext(ctx context.Context, o *Object, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("commit_append", err)
	}()
	if !o.Mode.IsAppend() {
		err = services.ObjectModeInvalidError{Expected: ModeAppend, Actual: o.Mode}
		return
	}

	pairs = append(pairs, s.defaultPairs.CommitAppend...)
	var opt pairStorageCommitAppend

	opt, err = s.parsePairStorageCommitAppend(pairs)
	if err != nil {
		return
	}

	return s.commitAppend(ctx, o, opt)
}

// Copy will copy an Object or multiple object in the service.
//
// This function will create a context by default.
func (s *Storage) Copy(src string, dst string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.CopyWithContext(ctx, src, dst, pairs...)
}

// CopyWithContext will copy an Object or multiple object in the service.
func (s *Storage) CopyWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("copy", err, src, dst)
	}()

	pairs = append(pairs, s.defaultPairs.Copy...)
	var opt pairStorageCopy

	opt, err = s.parsePairStorageCopy(pairs)
	if err != nil {
		return
	}

	return s.copy(ctx, src, dst, opt)
}

// Create will create a new object without any api call.
//
// This function will create a context by default.
func (s *Storage) Create(path string, pairs ...Pair) (o *Object) {
	pairs = append(pairs, s.defaultPairs.Create...)
	var opt pairStorageCreate

	// Ignore error while handling local funtions.
	opt, _ = s.parsePairStorageCreate(pairs)

	return s.create(path, opt)
}

// CreateAppend will create an append object.
//
// This function will create a context by default.
func (s *Storage) CreateAppend(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.CreateAppendWithContext(ctx, path, pairs...)
}

// CreateAppendWithContext will create an append object.
func (s *Storage) CreateAppendWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err = s.formatError("create_append", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreateAppend...)
	var opt pairStorageCreateAppend

	opt, err = s.parsePairStorageCreateAppend(pairs)
	if err != nil {
		return
	}

	return s.createAppend(ctx, path, opt)
}

// CreateDir will create a new dir object.
//
// This function will create a context by default.
func (s *Storage) CreateDir(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.CreateDirWithContext(ctx, path, pairs...)
}

// CreateDirWithContext will create a new dir object.
func (s *Storage) CreateDirWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err = s.formatError("create_dir", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreateDir...)
	var opt pairStorageCreateDir

	opt, err = s.parsePairStorageCreateDir(pairs)
	if err != nil {
		return
	}

	return s.createDir(ctx, path, opt)
}

// Delete will delete an Object from service.
//
// This function will create a context by default.
func (s *Storage) Delete(path string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.DeleteWithContext(ctx, path, pairs...)
}

// DeleteWithContext will delete an Object from service.
func (s *Storage) DeleteWithContext(ctx context.Context, path string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("delete", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Delete...)
	var opt pairStorageDelete

	opt, err = s.parsePairStorageDelete(pairs)
	if err != nil {
		return
	}

	return s.delete(ctx, path, opt)
}

// Fetch will fetch from a given url to path.
//
// This function will create a context by default.
func (s *Storage) Fetch(path string, url string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.FetchWithContext(ctx, path, url, pairs...)
}

// FetchWithContext will fetch from a given url to path.
func (s *Storage) FetchWithContext(ctx context.Context, path string, url string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("fetch", err, path, url)
	}()

	pairs = append(pairs, s.defaultPairs.Fetch...)
	var opt pairStorageFetch

	opt, err = s.parsePairStorageFetch(pairs)
	if err != nil {
		return
	}

	return s.fetch(ctx, path, url, opt)
}

// List will return list a specific path.
//
// This function will create a context by default.
func (s *Storage) List(path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	ctx := context.Background()
	return s.ListWithContext(ctx, path, pairs...)
}

// ListWithContext will return list a specific path.
func (s *Storage) ListWithContext(ctx context.Context, path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	defer func() {
		err = s.formatError("list", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.List...)
	var opt pairStorageList

	opt, err = s.parsePairStorageList(pairs)
	if err != nil {
		return
	}

	return s.list(ctx, path, opt)
}

// Metadata will return current storager metadata.
//
// This function will create a context by default.
func (s *Storage) Metadata(pairs ...Pair) (meta *StorageMeta) {
	pairs = append(pairs, s.defaultPairs.Metadata...)
	var opt pairStorageMetadata

	// Ignore error while handling local funtions.
	opt, _ = s.parsePairStorageMetadata(pairs)

	return s.metadata(opt)
}

// Move will move an object in the service.
//
// This function will create a context by default.
func (s *Storage) Move(src string, dst string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.MoveWithContext(ctx, src, dst, pairs...)
}

// MoveWithContext will move an object in the service.
func (s *Storage) MoveWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error) {
	defer func() {
		err = s.formatError("move", err, src, dst)
	}()

	pairs = append(pairs, s.defaultPairs.Move...)
	var opt pairStorageMove

	opt, err = s.parsePairStorageMove(pairs)
	if err != nil {
		return
	}

	return s.move(ctx, src, dst, opt)
}

// Read will read the file's data.
//
// This function will create a context by default.
func (s *Storage) Read(path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.ReadWithContext(ctx, path, w, pairs...)
}

// ReadWithContext will read the file's data.
func (s *Storage) ReadWithContext(ctx context.Context, path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	defer func() {
		err = s.formatError("read", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Read...)
	var opt pairStorageRead

	opt, err = s.parsePairStorageRead(pairs)
	if err != nil {
		return
	}

	return s.read(ctx, path, w, opt)
}

// Stat will stat a path to get info of an object.
//
// This function will create a context by default.
func (s *Storage) Stat(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.StatWithContext(ctx, path, pairs...)
}

// StatWithContext will stat a path to get info of an object.
func (s *Storage) StatWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err = s.formatError("stat", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Stat...)
	var opt pairStorageStat

	opt, err = s.parsePairStorageStat(pairs)
	if err != nil {
		return
	}

	return s.stat(ctx, path, opt)
}

// Write will write data into a file.
//
// This function will create a context by default.
func (s *Storage) Write(path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteWithContext(ctx, path, r, size, pairs...)
}

// WriteWithContext will write data into a file.
func (s *Storage) WriteWithContext(ctx context.Context, path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	defer func() {
		err = s.formatError("write", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Write...)
	var opt pairStorageWrite

	opt, err = s.parsePairStorageWrite(pairs)
	if err != nil {
		return
	}

	return s.write(ctx, path, r, size, opt)
}

// WriteAppend will append content to an append object.
//
// This function will create a context by default.
func (s *Storage) WriteAppend(o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteAppendWithContext(ctx, o, r, size, pairs...)
}

// WriteAppendWithContext will append content to an append object.
func (s *Storage) WriteAppendWithContext(ctx context.Context, o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	defer func() {
		err = s.formatError("write_append", err)
	}()
	if !o.Mode.IsAppend() {
		err = services.ObjectModeInvalidError{Expected: ModeAppend, Actual: o.Mode}
		return
	}

	pairs = append(pairs, s.defaultPairs.WriteAppend...)
	var opt pairStorageWriteAppend

	opt, err = s.parsePairStorageWriteAppend(pairs)
	if err != nil {
		return
	}

	return s.writeAppend(ctx, o, r, size, opt)
}

func init() {
	services.RegisterStorager(Type, NewStorager)
}
